========================================================================
========================================================================

履歴

	v1.1.1.6
		・cnvCAN2Cur関数を追加（内部値 -> 電流値[%]）
		・cnvCur2CAN関数を追加（電流値[%] -> 内部値）
		・cnvCAN2Trq関数を廃止（cnvCAN2Curに名称変更）

	v1.1.1.5
		・デバッグ関連の関数を追加（現在の所は、マルチパケット専用）

	v1.1.1.4
		・abh3_can_trans(CANa31.cpp)を変更
			重複した要求(CM_RTS)を受信した場合は、CM_ABORT(1)を送る
			戻り値の意味合いを変更

	v1.1.1.3
		・abh3_can_trans(CANa31.cpp)の処理を以下の様に変更
			送信に失敗したら、CM_ABORT(2)を送る（これはインターフェースがbusyと判断した結果）
			受信に失敗したら、CM_ABORT(3)を送る（タイムアウト扱い）
			PC側が受信ノード時、CM_CTSTの送信時に要求パケット数が固定（常に全数）だった点を
			要求位置から算出した残りパケット数に変更
			PC側が受信ノード時、CM_DTの受信時に「予定していたシーケンス番号」と異なる場合は再要求
		・ドキュメント追加
			CANa31導入.docx
			関数リファレンスforCANa31.docx

	v1.1.1.2
		・abh3_can_trans(CANa31.cpp)に渡す型の変更(size_t& -> uint32_t*)

	v1.1.1.1
		・abh3_can_trans(CANa31.cpp)内で中継するバッファが未開放だった点を修正

	v1.1.1.0
		・ソース内にコメント追加、機能には一切修正なし

	v1.1.0.0
		・CIxxatSimpleクラス内でsimpley_*関数を呼び出す時、同時発行されない様に変更
		　（元のSDKがスレッドセーフではない模様）
		　動作速度が大きく低下したが、回避方法は無い為、レスポンスに速度が要求される場合は、
		　CIxxatV2（＋利用可能なハードウェアの組み合わせ）で使用する事
		・abh3_can_trans関数を利用した時、本コード側でバッファを構築していたが、
		　上位アプリケーションとDLLのHEAP領域が共有出来ない場合(*1)、確保されたバッファを
		　正しく開放出来ない問題が有る為、関数仕様を以下の様に変更
		　変更前
		　	バッファは本コード側で確保（DLL側）
		　	作られたバッファのサイズも戻る
		　変更後
		　　バッファは上位側が確保して、バッファサイズを格納した変数と一緒に渡す
		　　通信結果がバッファに入りきらない場合は、バッファサイズの変数に
		　　「必要だったサイズ」が格納され、戻り値が-2に設定される
		　　通信結果が用意されたバッファで足りる場合は、内容が書き込まれ、
		　　バッファサイズの変数に「書き込まれたサイズ」が格納されて戻る

		　(*1)MFCアプリケーションからの利用等

	v1.0.0.5
		・CIxxat*::OnCanRecvの戻り値が0以外の時の説明を変更
		・cnvCANtoVolt関数の中身が、cnvCANtoVel相当の関数を呼び出していた点を修正
		　（計算結果が異なる問題を修正）

	v1.0.0.4
		・マルチパケット送信時、データ長が9バイト未満の場合は、SYNで足りない所を埋める
		　（余計なSYNは無視される為、本コードでは最低1つのSYNは追加される）
		　変更された関数
		　	int32_t CAbh3::abh3_can_trans(char* sbuf,char*& rbuf,size_t& rbuflen)

	v1.0.0.3以下
		割愛
